{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Strawberry Graphql Auth \u00b6 JWT Authentication / Authorization system for strawberry-django. Demo \u00b6 About \u00b6 Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation . Goals \u00b6 Easy JWT authentication compatible with strawberry. Some boiler-plate mutations like register, login etc. Non-goals \u00b6 Permission handling - out of scope for this project, we just provide you a user in info.context.request . Features \u00b6 Awesome docs! Captcha validation Async/Sync supported! django-channels asgi support. Works with default or custom user model Built-in JWT authentication. User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration You can now jump to the Tutorial .","title":"Start here"},{"location":"#strawberry-graphql-auth","text":"JWT Authentication / Authorization system for strawberry-django.","title":"Strawberry Graphql Auth"},{"location":"#demo","text":"","title":"Demo"},{"location":"#about","text":"Abstract all the basic logic of handling user accounts out of your app, so you don't need to think about it and can get you up and running faster . No lock-in. When you are ready to implement your own code or this package is not up to your expectations , it's easy to extend or switch to your implementation .","title":"About"},{"location":"#goals","text":"Easy JWT authentication compatible with strawberry. Some boiler-plate mutations like register, login etc.","title":"Goals"},{"location":"#non-goals","text":"Permission handling - out of scope for this project, we just provide you a user in info.context.request .","title":"Non-goals"},{"location":"#features","text":"Awesome docs! Captcha validation Async/Sync supported! django-channels asgi support. Works with default or custom user model Built-in JWT authentication. User registration with email verification Add secondary email, with email verification too Resend activation email Retrieve/Update user Archive user Permanently delete user or make it inactive Turn archived user active again on login Track user status (archived, verified, secondary email) Password change Password reset through email Revoke user tokens on account archive/delete/password change/reset All mutations return success and errors Default email templates (you will customize though) Customizable, no lock-in Passwordless registration You can now jump to the Tutorial .","title":"Features"},{"location":"api/","text":"auto generated using pydoc_markdown RegisterMixin \u00b6 class RegisterMixin ( BaseMixin ) Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived / verified. Send account verification email. If allowed to not verified users login, return token. VerifyAccountMixin \u00b6 class VerifyAccountMixin ( BaseMixin ) Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true. ResendActivationEmailMixin \u00b6 class ResendActivationEmailMixin ( BaseMixin ) Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned. SendPasswordResetEmailMixin \u00b6 class SendPasswordResetEmailMixin ( BaseMixin ) Send password reset email. For non verified users, send an activation email instead. If there is no user with the requested email, a successful response is returned. PasswordResetMixin \u00b6 class PasswordResetMixin ( BaseMixin ) Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. PasswordSetMixin \u00b6 class PasswordSetMixin ( BaseMixin ) Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it. ObtainJSONWebTokenMixin \u00b6 class ObtainJSONWebTokenMixin ( BaseMixin ) Obtain JSON web token for given user. Allow to perform login with different fields, The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase. ArchiveAccountMixin \u00b6 class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password. DeleteAccountMixin \u00b6 class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password. PasswordChangeMixin \u00b6 class PasswordChangeMixin ( BaseMixin ) Change account password when user knows the old password. A new token and refresh token are sent. User must be verified. UpdateAccountMixin \u00b6 class UpdateAccountMixin ( BaseMixin ) Update user model fields, defined on settings. User must be verified. VerifyTokenMixin \u00b6 class VerifyTokenMixin ( BaseMixin ) Checks if a token is not expired and correct. \u00b6 Note that this is not for refresh tokens. RefreshTokenMixin \u00b6 class RefreshTokenMixin ( BaseMixin ) refreshToken to generate a new login token: \u00b6 Use this only if JWT_LONG_RUNNING_REFRESH_TOKEN is True using the refresh-token you already got during authorization, and obtain a brand-new token (and possibly a new refresh token if you revoked the previous). This is an alternative to log in when your token expired. RevokeTokenMixin \u00b6 class RevokeTokenMixin ( BaseMixin ) Suspends a refresh token. \u00b6 token must exist to be revoked.","title":"API"},{"location":"api/#registermixin","text":"class RegisterMixin ( BaseMixin ) Register user with fields defined in the settings. If the email field of the user model is part of the registration fields (default), check if there is no user with that email. If it exists, it does not register the user, even if the email field is not defined as unique (default of the default django user model). When creating the user, it also creates a UserStatus related to that user, making it possible to track if the user is archived / verified. Send account verification email. If allowed to not verified users login, return token.","title":"RegisterMixin"},{"location":"api/#verifyaccountmixin","text":"class VerifyAccountMixin ( BaseMixin ) Verify user account. Receive the token that was sent by email. If the token is valid, make the user verified by making the user.status.verified field true.","title":"VerifyAccountMixin"},{"location":"api/#resendactivationemailmixin","text":"class ResendActivationEmailMixin ( BaseMixin ) Sends activation email. It is called resend because theoretically the first activation email was sent when the user registered. If there is no user with the requested email, a successful response is returned.","title":"ResendActivationEmailMixin"},{"location":"api/#sendpasswordresetemailmixin","text":"class SendPasswordResetEmailMixin ( BaseMixin ) Send password reset email. For non verified users, send an activation email instead. If there is no user with the requested email, a successful response is returned.","title":"SendPasswordResetEmailMixin"},{"location":"api/#passwordresetmixin","text":"class PasswordResetMixin ( BaseMixin ) Change user password without old password. Receive the token that was sent by email. If token and new passwords are valid, update user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordResetMixin"},{"location":"api/#passwordsetmixin","text":"class PasswordSetMixin ( BaseMixin ) Set user password - for password-less registration Receive the token that was sent by email. If token and new passwords are valid, set user password and in case of using refresh tokens, revoke all of them. Also, if user has not been verified yet, verify it.","title":"PasswordSetMixin"},{"location":"api/#obtainjsonwebtokenmixin","text":"class ObtainJSONWebTokenMixin ( BaseMixin ) Obtain JSON web token for given user. Allow to perform login with different fields, The fields are defined on settings. Not verified users can log in by default. This can be changes on settings. If user is archived, make it unarchived and return unarchiving=True on OutputBase.","title":"ObtainJSONWebTokenMixin"},{"location":"api/#archiveaccountmixin","text":"class ArchiveAccountMixin ( ArchiveOrDeleteMixin ) Archive account and revoke refresh tokens. User must be verified and confirm password.","title":"ArchiveAccountMixin"},{"location":"api/#deleteaccountmixin","text":"class DeleteAccountMixin ( ArchiveOrDeleteMixin ) Delete account permanently or make user.is_active=False . The behavior is defined on settings. Anyway user refresh tokens are revoked. User must be verified and confirm password.","title":"DeleteAccountMixin"},{"location":"api/#passwordchangemixin","text":"class PasswordChangeMixin ( BaseMixin ) Change account password when user knows the old password. A new token and refresh token are sent. User must be verified.","title":"PasswordChangeMixin"},{"location":"api/#updateaccountmixin","text":"class UpdateAccountMixin ( BaseMixin ) Update user model fields, defined on settings. User must be verified.","title":"UpdateAccountMixin"},{"location":"api/#verifytokenmixin","text":"class VerifyTokenMixin ( BaseMixin )","title":"VerifyTokenMixin"},{"location":"api/#checks-if-a-token-is-not-expired-and-correct","text":"Note that this is not for refresh tokens.","title":"Checks if a token is not expired and correct."},{"location":"api/#refreshtokenmixin","text":"class RefreshTokenMixin ( BaseMixin )","title":"RefreshTokenMixin"},{"location":"api/#refreshtoken-to-generate-a-new-login-token","text":"Use this only if JWT_LONG_RUNNING_REFRESH_TOKEN is True using the refresh-token you already got during authorization, and obtain a brand-new token (and possibly a new refresh token if you revoked the previous). This is an alternative to log in when your token expired.","title":"refreshToken to generate a new login token:"},{"location":"api/#revoketokenmixin","text":"class RevokeTokenMixin ( BaseMixin )","title":"RevokeTokenMixin"},{"location":"api/#suspends-a-refresh-token","text":"token must exist to be revoked.","title":"Suspends a refresh token."},{"location":"captcha/","text":"Captcha \u00b6 this package provides a fully functional captcha validation system the default setting are: LOGIN_REQUIRE_CAPTCHA = True , REGISTER_REQUIRE_CAPTCHA = True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"captcha/#captcha","text":"this package provides a fully functional captcha validation system the default setting are: LOGIN_REQUIRE_CAPTCHA = True , REGISTER_REQUIRE_CAPTCHA = True , if you don't like this set them to False. The Captcha is available to query via a base64 encoded string or via a static .png image. Note: The Image is in PNG format base64 static mutation MyMutation { captcha { uuid pilImage } } You will further be needed to implement a translation in the UI. For the creation of a static set CAPTCHA_SAVE_IMAGE = True on your settings. This will use django's Imagefield to store the captcha image. You will also be needed to include a path in your urlpatterns for development, as per the documentation . mutation MyMutation { captcha { uuid image{ width height url } } }","title":"Captcha"},{"location":"changelog/","text":"Release type: minor This release updates to the latest version of strawberry and removes dependencies with strawberry-django-plus. The directive IsVerified is migrated to the new field extensions API and extends the django base permission extension. The Channels middleware will inject the user in request.user or request.scope[\"UserOrError\"]","title":"Changelog"},{"location":"channels/","text":"In order to have a user in your context from headers our django middleware would not suffice. you would need to user our channels middleware. Here is an example of an asgi.py file that uses our middleware to support JWT from headers: asgi.py from gqlauth.core.middlewares import channels_jwt_middleware ... websocket_urlpatterns = [ re_path ( \"^graphql\" , channels_jwt_middleware ( GraphQLWSConsumer . as_asgi ( schema = arg_schema ))), ] gql_http_consumer = AuthMiddlewareStack ( channels_jwt_middleware ( GraphQLHTTPConsumer . as_asgi ( schema = arg_schema )) ) application = ProtocolTypeRouter ( { \"http\" : URLRouter ( [ re_path ( \"^graphql\" , gql_http_consumer ), ] ), \"websocket\" : AuthMiddlewareStack ( URLRouter ( websocket_urlpatterns )), } ) Now in order to have the user inside info.context.request we need to use a custom schema schema.py from gqlauth.core.middlewares import JwtSchema arg_schema = JwtSchema ( query = Query , mutation = Mutation , subscription = Subscription ] )","title":"Channels"},{"location":"contributing/","text":"Contributing \u00b6 Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests Getting started \u00b6 If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out. Project setup \u00b6 After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox Running tests \u00b6 After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__> Opening Pull Requests \u00b6 Please fork the project and open a pull request against the main branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint Documentation \u00b6 The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thanks for helping improve Django GraphQL Auth! All kinds of contributions are welcome: Bug fixes Documentation improvements New features Refactoring Fix some typo Write more tests","title":"Contributing"},{"location":"contributing/#getting-started","text":"If you have a specific contribution in mind, be sure to check the issues and projects in progress - someone could already be working on something similar and you can help out.","title":"Getting started"},{"location":"contributing/#project-setup","text":"After cloning this repo, ensure dependencies are installed by running: make dev-setup and pip install tox","title":"Project setup"},{"location":"contributing/#running-tests","text":"After developing, you can run tests with: # python=3.7 and django=3.0 make test You can specify versions, for the full list see the tox.ini file. # python=3.6 and django=2.2 make test p = 36 d = 22 Test directly with tox: tox Single file test shortcut: # run only tests in tests/test_register.py make test-file f = register For live testing on a django project, you can use the testproject. Create a different virtualenv, install the dependencies again and run: cd testproject make install-local v = <CURRENT VERSION IN gqlauth.__init__>","title":"Running tests"},{"location":"contributing/#opening-pull-requests","text":"Please fork the project and open a pull request against the main branch. This will trigger a series of tests and lint checks. We advise that you format and run lint locally before doing this to save time: make format make lint","title":"Opening Pull Requests"},{"location":"contributing/#documentation","text":"The documentation is generated using the excellent MkDocs with material theme . The documentation dependencies are installed by running: pip install -r docs/requirements.txt Then to produce a HTML version of the documentation, for live editing: make serve It will run the docs/pre_build.py script before building the docs.","title":"Documentation"},{"location":"contributors/","text":"Contributors \u00b6 @pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"contributors/#contributors","text":"@pedrobern @nrbnlulu @yanivtoledano @ulgens @panosangelopoulos @pors @bzhr @maxpeterson @boolangery @capaci @mnieber @joshuachinemezu @imsheldon","title":"Contributors"},{"location":"overriding-email-templates/","text":"Overriding Email Templates \u00b6 The default email templates are just examples, you probably want to customize it. Update your settings: \u00b6 # settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ] File and folder sctructure \u00b6 Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email Email variables \u00b6 Both subject and email templates receive the following variables: user token \u2192 account activation / password reset port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings Writing the templates \u00b6 Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Overriding email templates"},{"location":"overriding-email-templates/#overriding-email-templates","text":"The default email templates are just examples, you probably want to customize it.","title":"Overriding Email Templates"},{"location":"overriding-email-templates/#update-your-settings","text":"# settings.py import os TEMPLATES = [ { #... \"DIRS\" : [ os . path . join ( BASE_DIR , \"templates\" )], # ... }, ]","title":"Update your settings:"},{"location":"overriding-email-templates/#file-and-folder-sctructure","text":"Create the following folder and files structure: - project_name/ - project_name/ - templates/ email/ activation_email.html activation_subject.txt password_reset_email.html password_reset_subject.txt db.sqlite3 manage.py This is the minimum. Check the email templates settings , you can create custom templates for: account activation resend account activation email password reset email","title":"File and folder sctructure"},{"location":"overriding-email-templates/#email-variables","text":"Both subject and email templates receive the following variables: user token \u2192 account activation / password reset port site_name \u2192 from django sites framework (optional) domain \u2192 from django sites framework (optional) protocol path \u2192 defined in settings (some frontend path) request timestamp custom variables defined using EMAIL_TEMPLATE_VARIABLES setting \u2192 defined in settings","title":"Email variables"},{"location":"overriding-email-templates/#writing-the-templates","text":"Write your templates like this: <!-- activation_email.html --> < h3 > {{ site_name }} </ h3 > < p > Hello \\{{ user.username }}! </ p > < p > Please activate your account on the link: </ p > < p > {{ protocol }}://{{ domain }}/{{ path }}/{{ token }} </ p > Provide only the html template. It will be converted to text later.","title":"Writing the templates"},{"location":"relay/","text":"Relay \u00b6 Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field Note that relay is not supported for queries yet. \u00b6","title":"Relay"},{"location":"relay/#relay","text":"Import mutations from the relay module: import strawberry from gqlauth.user import relay @strawberry . type class AuthMutation : register = relay . Register . field","title":"Relay"},{"location":"relay/#note-that-relay-is-not-supported-for-queries-yet","text":"","title":"Note that relay is not supported for queries yet."},{"location":"settings/","text":"auto generated using pydoc_markdown GqlAuthSettings \u00b6 @dataclass class GqlAuthSettings () ALLOW_LOGIN_NOT_VERIFIED \u00b6 LOGIN_FIELDS \u00b6 These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. You can pass any fields that would be accepted by your backends. Note that password field is mandatory and cannot be removed. LOGIN_REQUIRE_CAPTCHA \u00b6 Whether login will require captcha verification. REGISTER_MUTATION_FIELDS \u00b6 Fields on register, plus password1 and password2, can be a dict like UPDATE_MUTATION_fieldS setting. REGISTER_REQUIRE_CAPTCHA \u00b6 Whether register will require captcha verification. CAPTCHA_EXPIRATION_DELTA \u00b6 captcha stuff captcha expiration delta. CAPTCHA_MAX_RETRIES \u00b6 max number of attempts for one captcha. CAPTCHA_TEXT_FACTORY \u00b6 A callable with no arguments that returns a string. This will be used to generate the captcha image. CAPTCHA_TEXT_VALIDATOR \u00b6 A callable that will receive the original string vs user input and returns a boolean. FORCE_SHOW_CAPTCHA \u00b6 Whether to show the captcha image after it has been created for debugging purposes. CAPTCHA_SAVE_IMAGE \u00b6 If True, an png representation of the captcha will be saved under MEDIA_ROOT/captcha/ / .png. UPDATE_MUTATION_FIELDS \u00b6 Fields on update account mutation. ALLOW_DELETE_ACCOUNT \u00b6 If True, DeleteAcount mutation will permanently delete the user. ALLOW_PASSWORDLESS_REGISTRATION \u00b6 Whether to allow registration with no password. JWT_SECRET_KEY \u00b6 Key used to sign the JWT token. JWT_ALGORITHM \u00b6 Algorithm used for signing the token. JWT_TIME_FORMAT \u00b6 A valid 'strftime' string that will be used to encode the token payload. JWT_PAYLOAD_HANDLER \u00b6 A custom function to generate the token datatype, its up to you to encode the token. JWT_PAYLOAD_PK \u00b6 Field that will be used to generate the token from a user instance and retrieve user based on the decoded token. This filed must be unique in the database JWT_TOKEN_FINDER \u00b6 A hook called by GqlAuthRootField to find the token. Accepts the request object (might be channels scope dict or django request object) remember to strip the \"JWT \" prefix if you override this. JWT_EXPIRATION_DELTA \u00b6 Timedelta added to utcnow() to set the expiration time. When this ends you will have to create a new token by logging in or using the refresh token. JWT_LONG_RUNNING_REFRESH_TOKEN \u00b6 Whether to enable refresh tokens to be used as an alternative to login every time the token is expired. JWT_REFRESH_TOKEN_N_BYTES \u00b6 Number of bytes for long running refresh token. JWT_REFRESH_EXPIRATION_DELTA \u00b6 Refresh token expiration time delta.","title":"Settings"},{"location":"settings/#gqlauthsettings","text":"@dataclass class GqlAuthSettings ()","title":"GqlAuthSettings"},{"location":"settings/#allow_login_not_verified","text":"","title":"ALLOW_LOGIN_NOT_VERIFIED"},{"location":"settings/#login_fields","text":"These fields would be used to authenticate with SD-jwt authenticate function. This function will call each of our AUTHENTICATION_BACKENDS , And will return the user from one of them unless PermissionDenied was raised. You can pass any fields that would be accepted by your backends. Note that password field is mandatory and cannot be removed.","title":"LOGIN_FIELDS"},{"location":"settings/#login_require_captcha","text":"Whether login will require captcha verification.","title":"LOGIN_REQUIRE_CAPTCHA"},{"location":"settings/#register_mutation_fields","text":"Fields on register, plus password1 and password2, can be a dict like UPDATE_MUTATION_fieldS setting.","title":"REGISTER_MUTATION_FIELDS"},{"location":"settings/#register_require_captcha","text":"Whether register will require captcha verification.","title":"REGISTER_REQUIRE_CAPTCHA"},{"location":"settings/#captcha_expiration_delta","text":"captcha stuff captcha expiration delta.","title":"CAPTCHA_EXPIRATION_DELTA"},{"location":"settings/#captcha_max_retries","text":"max number of attempts for one captcha.","title":"CAPTCHA_MAX_RETRIES"},{"location":"settings/#captcha_text_factory","text":"A callable with no arguments that returns a string. This will be used to generate the captcha image.","title":"CAPTCHA_TEXT_FACTORY"},{"location":"settings/#captcha_text_validator","text":"A callable that will receive the original string vs user input and returns a boolean.","title":"CAPTCHA_TEXT_VALIDATOR"},{"location":"settings/#force_show_captcha","text":"Whether to show the captcha image after it has been created for debugging purposes.","title":"FORCE_SHOW_CAPTCHA"},{"location":"settings/#captcha_save_image","text":"If True, an png representation of the captcha will be saved under MEDIA_ROOT/captcha/ / .png.","title":"CAPTCHA_SAVE_IMAGE"},{"location":"settings/#update_mutation_fields","text":"Fields on update account mutation.","title":"UPDATE_MUTATION_FIELDS"},{"location":"settings/#allow_delete_account","text":"If True, DeleteAcount mutation will permanently delete the user.","title":"ALLOW_DELETE_ACCOUNT"},{"location":"settings/#allow_passwordless_registration","text":"Whether to allow registration with no password.","title":"ALLOW_PASSWORDLESS_REGISTRATION"},{"location":"settings/#jwt_secret_key","text":"Key used to sign the JWT token.","title":"JWT_SECRET_KEY"},{"location":"settings/#jwt_algorithm","text":"Algorithm used for signing the token.","title":"JWT_ALGORITHM"},{"location":"settings/#jwt_time_format","text":"A valid 'strftime' string that will be used to encode the token payload.","title":"JWT_TIME_FORMAT"},{"location":"settings/#jwt_payload_handler","text":"A custom function to generate the token datatype, its up to you to encode the token.","title":"JWT_PAYLOAD_HANDLER"},{"location":"settings/#jwt_payload_pk","text":"Field that will be used to generate the token from a user instance and retrieve user based on the decoded token. This filed must be unique in the database","title":"JWT_PAYLOAD_PK"},{"location":"settings/#jwt_token_finder","text":"A hook called by GqlAuthRootField to find the token. Accepts the request object (might be channels scope dict or django request object) remember to strip the \"JWT \" prefix if you override this.","title":"JWT_TOKEN_FINDER"},{"location":"settings/#jwt_expiration_delta","text":"Timedelta added to utcnow() to set the expiration time. When this ends you will have to create a new token by logging in or using the refresh token.","title":"JWT_EXPIRATION_DELTA"},{"location":"settings/#jwt_long_running_refresh_token","text":"Whether to enable refresh tokens to be used as an alternative to login every time the token is expired.","title":"JWT_LONG_RUNNING_REFRESH_TOKEN"},{"location":"settings/#jwt_refresh_token_n_bytes","text":"Number of bytes for long running refresh token.","title":"JWT_REFRESH_TOKEN_N_BYTES"},{"location":"settings/#jwt_refresh_expiration_delta","text":"Refresh token expiration time delta.","title":"JWT_REFRESH_EXPIRATION_DELTA"},{"location":"tutorial/","text":"What to expect \u00b6 Fully functional API to handle user account Setup with custom user model 20 to 30 minutes Final code on github . Requirements \u00b6 Python: >= 3.8 Django: >= 3.2 Basic knowledge in Strawberry Start a new Django Project \u00b6 It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first. Create the virtual env \u00b6 python -m venv venv cd venv/bin source activate.sh Create the Django Project \u00b6 First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart Create the custom user model \u00b6 Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py makemigrations python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings . Install strawberry-django-auth \u00b6 # quickstart.settings.py from gqlauth.settings_type import GqlAuthSettings INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" , \"gqlauth\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'gqlauth.core.middlewares.django_jwt_middleware' # ... ] AUTHENTICATION_BACKENDS = [ \"django.contrib.auth.backends.ModelBackend\" , ] We will disable captcha validation for now, just for ease of setup. from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate Create the schema \u00b6 Create a file called schema.py next to your settings.py Add the following to code: # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries Default Relay from gqlauth.user import arg_mutations as mutations from gqlauth.user import relay as mutations @strawberry . type class Query ( UserQueries ): # you can add your queries here ... you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc... @strawberry . type class Mutation : # include what-ever mutations you want. verify_token = mutations . VerifyToken . field update_account = mutations . UpdateAccount . field archive_account = mutations . ArchiveAccount . field delete_account = mutations . DeleteAccount . field password_change = mutations . PasswordChange . field swap_emails = mutations . SwapEmails . field captcha = Captcha . field token_auth = mutations . ObtainJSONWebToken . field register = mutations . Register . field verify_account = mutations . VerifyAccount . field resend_activation_email = mutations . ResendActivationEmail . field send_password_reset_email = mutations . SendPasswordResetEmail . field password_reset = mutations . PasswordReset . field password_set = mutations . PasswordSet . field refresh_token = mutations . RefreshToken . field revoke_token = mutations . RevokeToken . field verify_secondary_email = mutations . VerifySecondaryEmail . field schema = strawberry . Schema ( query = Query , mutation = Mutation ) Load fixtures \u00b6 Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False You can access it on any user: user.status. [ verified | archived ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false } } ] run: python -m manage loaddata users.json Making your first query \u00b6 Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql First let's log-in: \u00b6 Setup Email Backend \u00b6 The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to set up a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email, and we are ready to continue this guide. Let's try to register a new user: \u00b6 Too weak password gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: successful registration arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } There is actually a new user, it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw Verify the new user. \u00b6 search your schema for verify_account : should look like this: Now let's try to verify the account: Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } } Login \u00b6 search your schema for tokenAuth : should look like this: Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } mutation { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"token\" : { \"payload\" : { \"origIat\" : \"2022-09-18T14:56:33.829961\" , \"exp\" : \"2022-09-18T15:01:33.829961\" }, \"token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXlsb2FkIjoie1xuIFwiZXhwXCI6IFwiMjAyMi0wOS0xOFQxNTowMTozMy44Mjk5NjFcIixcbiBcIm9yaWdJYXRcIjogXCIyMDIyLTA5LTE4VDE0OjU2OjMzLjgyOTk2MVwiLFxuIFwidXNlcm5hbWVcIjogXCJuZXdfdXNlclwiXG59In0.2qSD_203UCa4EmtiDz-YtbO59ETaLfLGj7R_6c2197Y\" }, \"user\" : { \"isActive\" : true , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"status\" : { \"verified\" : true } } } } } Save this token , we are going to use it in the request headers. MeQuery \u00b6 With MeQuery you can retrieve data for the currently authenticated user: No headers supplied, will raise graphql error query response query{ me{ username verified } } { \"data\" : null , \"errors\" : [ { \"message\" : \"User is not authenticated.\" , \"locations\" : [ { \"line\" : 2 , \"column\" : 3 } ], \"path\" : [ \"me\" ] } ] } With the token from last mutation, we can access the data. Add The token in the Headers section in GraphiQL query response query{ me{ username verified } } { \"data\" : { \"me\" : { \"verified\" : true , \"username\" : \"testadmin\" } } } If it fails because of the token (in case you took some time, and it has expired), make the login again and get a new token. Next steps \u00b6 explore all the mutations. Support Django-Channels . Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . make sure you are familiar with our captcha system. Override email templates .","title":"Tutorial"},{"location":"tutorial/#what-to-expect","text":"Fully functional API to handle user account Setup with custom user model 20 to 30 minutes Final code on github .","title":"What to expect"},{"location":"tutorial/#requirements","text":"Python: >= 3.8 Django: >= 3.2 Basic knowledge in Strawberry","title":"Requirements"},{"location":"tutorial/#start-a-new-django-project","text":"It's recommended to use virtual env wrapper or virtualenv to create your project inside an isolated python environment. We will use the first.","title":"Start a new Django Project"},{"location":"tutorial/#create-the-virtual-env","text":"python -m venv venv cd venv/bin source activate.sh","title":"Create the virtual env"},{"location":"tutorial/#create-the-django-project","text":"First install django: python -m pip install django Then, create the new project: django-admin startproject quickstart cd quickstart","title":"Create the Django Project"},{"location":"tutorial/#create-the-custom-user-model","text":"Changing to a custom user model mid-project is significantly more difficult. So let's start by adding it now. Run the following: python manage.py startapp users Then, create the custom user model: # users/models.py from django.contrib.auth.models import AbstractUser class CustomUser ( AbstractUser ): email = models . EmailField ( blank = False , max_length = 254 , verbose_name = \"email address\" ) USERNAME_FIELD = \"username\" # e.g: \"username\", \"email\" EMAIL_FIELD = \"email\" # e.g: \"email\", \"primary_email\" Add it to the settings: # quickstart/settings.py INSTALLED_APPS = [ # ... 'users' ] AUTH_USER_MODEL = 'users.CustomUser' Finally, migrate: python manage.py makemigrations python manage.py migrate You can customize the mutations to match your custom user model fields, see the dynamic-fields settings .","title":"Create the custom user model"},{"location":"tutorial/#install-strawberry-django-auth","text":"# quickstart.settings.py from gqlauth.settings_type import GqlAuthSettings INSTALLED_APPS = [ # ... 'django.contrib.staticfiles' , # Required for GraphiQL \"strawberry_django\" , \"gqlauth\" , ] MIDDLEWARE = [ # ... 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'gqlauth.core.middlewares.django_jwt_middleware' # ... ] AUTHENTICATION_BACKENDS = [ \"django.contrib.auth.backends.ModelBackend\" , ] We will disable captcha validation for now, just for ease of setup. from gqlauth.settings_type import GqlAuthSettings GQL_AUTH = GqlAuthSettings ( LOGIN_REQUIRE_CAPTCHA = False , REGISTER_REQUIRE_CAPTCHA = False , ) And make sure your templates configuration has the following: TEMPLATES = [ { # ... 'APP_DIRS' : True , }, ] Run: python -m manage migrate","title":"Install strawberry-django-auth"},{"location":"tutorial/#create-the-schema","text":"Create a file called schema.py next to your settings.py Add the following to code: # yourapp/users/schema.py import strawberry from gqlauth.user.queries import UserQueries Default Relay from gqlauth.user import arg_mutations as mutations from gqlauth.user import relay as mutations @strawberry . type class Query ( UserQueries ): # you can add your queries here ... you can choose what fields to include like this import strawberry from gqlauth.user.queries import UserQueries , UserType from django.contrib.auth import get_user_model @strawberry . django . type ( model = get_user_model ()) class MyQueries : me : UserType = UserQueries . me public : UserType = UserQueries . public_user # etc... @strawberry . type class Mutation : # include what-ever mutations you want. verify_token = mutations . VerifyToken . field update_account = mutations . UpdateAccount . field archive_account = mutations . ArchiveAccount . field delete_account = mutations . DeleteAccount . field password_change = mutations . PasswordChange . field swap_emails = mutations . SwapEmails . field captcha = Captcha . field token_auth = mutations . ObtainJSONWebToken . field register = mutations . Register . field verify_account = mutations . VerifyAccount . field resend_activation_email = mutations . ResendActivationEmail . field send_password_reset_email = mutations . SendPasswordResetEmail . field password_reset = mutations . PasswordReset . field password_set = mutations . PasswordSet . field refresh_token = mutations . RefreshToken . field revoke_token = mutations . RevokeToken . field verify_secondary_email = mutations . VerifySecondaryEmail . field schema = strawberry . Schema ( query = Query , mutation = Mutation )","title":"Create the schema"},{"location":"tutorial/#load-fixtures","text":"Before starting to query, let's load some users on the database. Create a new file called users.json in the same directory as manage.py with the following: Have a look on the fixtures, note that we are creating 4 users and 3 UserStatus . When creating a user, we create a relating UserStatus by default on post_save signal with the following fields: verified = False archived = False You can access it on any user: user.status. [ verified | archived ] [ { \"model\" : \"users.CustomUser\" , \"pk\" : 1 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user1\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user1@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 2 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user2\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user2@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 2 , \"fields\" : { \"user\" : 2 , \"verified\" : true , \"archived\" : false } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 3 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user3\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user3@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 3 , \"fields\" : { \"user\" : 3 , \"verified\" : true , \"archived\" : true } }, { \"model\" : \"users.CustomUser\" , \"pk\" : 4 , \"fields\" : { \"password\" : \"pbkdf2_sha256$180000$nFcBtiqGnWN9$hf58wNg77oT1BlNKRdATVVvBIa69+dz22fL1JKOKTaA=\" , \"last_login\" : null , \"is_superuser\" : false , \"username\" : \"user4\" , \"first_name\" : \"\" , \"last_name\" : \"\" , \"email\" : \"user4@email.com\" , \"is_staff\" : false , \"is_active\" : true } }, { \"model\" : \"gqlauth.userstatus\" , \"pk\" : 4 , \"fields\" : { \"user\" : 4 , \"verified\" : true , \"archived\" : false } } ] run: python -m manage loaddata users.json","title":"Load fixtures"},{"location":"tutorial/#making-your-first-query","text":"Start the dev server: python manage.py runserver Open your browser: http://127.0.0.1:8000/graphql","title":"Making your first query"},{"location":"tutorial/#first-lets-log-in","text":"","title":"First let's log-in:"},{"location":"tutorial/#setup-email-backend","text":"The default configuration is to send activation email when registering users, you can set it to False on your settings , but you still need an Email Backend to password reset. The quickest solution for development is to set up a Console Email Backend , simply add the following to your settings.py . EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' Now all emails are sent to the standard output, instead of an actual email, and we are ready to continue this guide.","title":"Setup Email Backend"},{"location":"tutorial/#lets-try-to-register-a-new-user","text":"Too weak password gql relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", ) { success, errors, } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"123456\", password2: \"123456\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : false , \"errors\" : { \"password2\" : [ { \"message\" : \"This password is too short. It must contain at least 8 characters.\" , \"code\" : \"password_too_short\" }, { \"message\" : \"This password is too common.\" , \"code\" : \"password_too_common\" }, { \"message\" : \"This password is entirely numeric.\" , \"code\" : \"password_entirely_numeric\" } ] } } } } Something went wrong! Now you know the response format that you can expect of all mutations. Let's try again: successful registration arg_mutation relay response mutation { register( email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", ) { success, errors, success } } mutation { register( input: { email: \"new_user@email.com\", username: \"new_user\", password1: \"SuperSecureP@sw0rd\", password2: \"SuperSecureP@sw0rd\", } ) { success, errors, token, refreshToken } } { \"data\" : { \"register\" : { \"success\" : true , \"errors\" : null } } } There is actually a new user, it is possible to log in (you can change it on the settings ), but it is not verified yet. Save the id of the new user, so we can query it later. Go to your console and note the email that has been sent. Should be two outputs, html and plain text formats. Save the token from the url, something like this: eyJ1c2VybmFtZSI6Im5ld191c2VyIiwiYWN0aW9uIjoiYWN0aXZhdGlvbiJ9:1isoSr:CDwK_fjBSxWj3adC-X16wqzv-Mw","title":"Let's try to register a new user:"},{"location":"tutorial/#verify-the-new-user","text":"search your schema for verify_account : should look like this: Now let's try to verify the account: Gql arg_mutation relay result mutation { verifyAccount(token: \"YOUR TOKEN HERE\") { success, errors } } mutation { verifyAccount ( input : { token : \"<YOUR TOKEN HERE>\" } ) { success , errors } } { \"data\" : { \"verifyAccount\" : { \"success\" : true , \"errors\" : null } } }","title":"Verify the new user."},{"location":"tutorial/#login","text":"search your schema for tokenAuth : should look like this: Gql arg_mutation relay response mutation { tokenAuth(username: \"new_user\", password: \"SuperSecureP@sw0rd\") { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } mutation { tokenAuth(input: {username: \"new_user\", password: \"SuperSecureP@sw0rd\"}) { success errors token { payload { origIat exp } token } user { isActive username email status { verified } } } } { \"data\" : { \"tokenAuth\" : { \"success\" : true , \"errors\" : null , \"token\" : { \"payload\" : { \"origIat\" : \"2022-09-18T14:56:33.829961\" , \"exp\" : \"2022-09-18T15:01:33.829961\" }, \"token\" : \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwYXlsb2FkIjoie1xuIFwiZXhwXCI6IFwiMjAyMi0wOS0xOFQxNTowMTozMy44Mjk5NjFcIixcbiBcIm9yaWdJYXRcIjogXCIyMDIyLTA5LTE4VDE0OjU2OjMzLjgyOTk2MVwiLFxuIFwidXNlcm5hbWVcIjogXCJuZXdfdXNlclwiXG59In0.2qSD_203UCa4EmtiDz-YtbO59ETaLfLGj7R_6c2197Y\" }, \"user\" : { \"isActive\" : true , \"username\" : \"new_user\" , \"email\" : \"new_user@email.com\" , \"status\" : { \"verified\" : true } } } } } Save this token , we are going to use it in the request headers.","title":"Login"},{"location":"tutorial/#mequery","text":"With MeQuery you can retrieve data for the currently authenticated user: No headers supplied, will raise graphql error query response query{ me{ username verified } } { \"data\" : null , \"errors\" : [ { \"message\" : \"User is not authenticated.\" , \"locations\" : [ { \"line\" : 2 , \"column\" : 3 } ], \"path\" : [ \"me\" ] } ] } With the token from last mutation, we can access the data. Add The token in the Headers section in GraphiQL query response query{ me{ username verified } } { \"data\" : { \"me\" : { \"verified\" : true , \"username\" : \"testadmin\" } } } If it fails because of the token (in case you took some time, and it has expired), make the login again and get a new token.","title":"MeQuery"},{"location":"tutorial/#next-steps","text":"explore all the mutations. Support Django-Channels . Navigate through the GraphiQL Documentation Explorer. Change the settings . Explore the api . make sure you are familiar with our captcha system. Override email templates .","title":"Next steps"}]}